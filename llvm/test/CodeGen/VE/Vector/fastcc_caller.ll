; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=ve-unknown-unknown -mattr=+vpu | FileCheck %s


declare i32 @sample_add(i32, i32)
declare i32 @stack_callee_int(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32)
declare i32 @stack_callee_int_szext(i1 signext, i8 zeroext, i32, i32, i32, i32, i32, i32, i16 zeroext, i8 signext)
declare float @stack_callee_float(float, float, float, float, float, float, float, float, float, float)
declare void @test(i64)

; Scalar argument passing must not change (same tests as in VE/Scalar/call.ll below - this time with +vpu)

define fastcc i32 @sample_call() {
; CHECK-LABEL: sample_call:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB0_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB0_2:
; CHECK-NEXT:    lea %s0, sample_add@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, sample_add@hi(, %s0)
; CHECK-NEXT:    or %s0, 1, (0)1
; CHECK-NEXT:    or %s1, 2, (0)1
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %r = tail call fastcc i32 @sample_add(i32 1, i32 2)
  ret i32 %r
}

define fastcc i32 @stack_call_int() {
; CHECK-LABEL: stack_call_int:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB1_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB1_2:
; CHECK-NEXT:    or %s0, 10, (0)1
; CHECK-NEXT:    st %s0, 248(, %s11)
; CHECK-NEXT:    or %s34, 9, (0)1
; CHECK-NEXT:    lea %s0, stack_callee_int@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, stack_callee_int@hi(, %s0)
; CHECK-NEXT:    or %s0, 1, (0)1
; CHECK-NEXT:    or %s1, 2, (0)1
; CHECK-NEXT:    or %s2, 3, (0)1
; CHECK-NEXT:    or %s3, 4, (0)1
; CHECK-NEXT:    or %s4, 5, (0)1
; CHECK-NEXT:    or %s5, 6, (0)1
; CHECK-NEXT:    or %s6, 7, (0)1
; CHECK-NEXT:    or %s7, 8, (0)1
; CHECK-NEXT:    st %s34, 240(, %s11)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %r = tail call fastcc i32 @stack_callee_int(i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10)
  ret i32 %r
}

define fastcc i32 @stack_call_int_szext() {
; CHECK-LABEL: stack_call_int_szext:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB2_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB2_2:
; CHECK-NEXT:    or %s0, -1, (0)1
; CHECK-NEXT:    st %s0, 248(, %s11)
; CHECK-NEXT:    lea %s34, 65535
; CHECK-NEXT:    lea %s0, stack_callee_int_szext@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, stack_callee_int_szext@hi(, %s0)
; CHECK-NEXT:    or %s0, -1, (0)1
; CHECK-NEXT:    lea %s1, 255
; CHECK-NEXT:    or %s2, 3, (0)1
; CHECK-NEXT:    or %s3, 4, (0)1
; CHECK-NEXT:    or %s4, 5, (0)1
; CHECK-NEXT:    or %s5, 6, (0)1
; CHECK-NEXT:    or %s6, 7, (0)1
; CHECK-NEXT:    or %s7, 8, (0)1
; CHECK-NEXT:    st %s34, 240(, %s11)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %r = tail call fastcc i32 @stack_callee_int_szext(i1 -1, i8 -1, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i16 -1, i8 -1)
  ret i32 %r
}

define fastcc float @stack_call_float() {
; CHECK-LABEL: stack_call_float:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB3_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB3_2:
; CHECK-NEXT:    lea.sl %s0, 1092616192
; CHECK-NEXT:    st %s0, 248(, %s11)
; CHECK-NEXT:    lea.sl %s34, 1091567616
; CHECK-NEXT:    lea %s0, stack_callee_float@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, stack_callee_float@hi(, %s0)
; CHECK-NEXT:    lea.sl %s0, 1065353216
; CHECK-NEXT:    lea.sl %s1, 1073741824
; CHECK-NEXT:    lea.sl %s2, 1077936128
; CHECK-NEXT:    lea.sl %s3, 1082130432
; CHECK-NEXT:    lea.sl %s4, 1084227584
; CHECK-NEXT:    lea.sl %s5, 1086324736
; CHECK-NEXT:    lea.sl %s6, 1088421888
; CHECK-NEXT:    lea.sl %s7, 1090519040
; CHECK-NEXT:    st %s34, 240(, %s11)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %r = tail call fastcc float @stack_callee_float(float 1.0, float 2.0, float 3.0, float 4.0, float 5.0, float 6.0, float 7.0, float 8.0, float 9.0, float 10.0)
  ret float %r
}

define fastcc float @stack_call_float2(float %p0) {
; CHECK-LABEL: stack_call_float2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB4_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB4_2:
; CHECK-NEXT:    st %s0, 248(, %s11)
; CHECK-NEXT:    lea %s1, stack_callee_float@lo
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    lea.sl %s12, stack_callee_float@hi(, %s1)
; CHECK-NEXT:    st %s0, 240(, %s11)
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    or %s2, 0, %s0
; CHECK-NEXT:    or %s3, 0, %s0
; CHECK-NEXT:    or %s4, 0, %s0
; CHECK-NEXT:    or %s5, 0, %s0
; CHECK-NEXT:    or %s6, 0, %s0
; CHECK-NEXT:    or %s7, 0, %s0
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %r = tail call fastcc float @stack_callee_float(float %p0, float %p0, float %p0, float %p0, float %p0, float %p0, float %p0, float %p0, float %p0, float %p0)
  ret float %r
}

; Vector argument passing (fastcc feature)
;
declare fastcc <256 x i32> @get_v256i32()
declare fastcc void @vsample_v(<256 x i32>)
declare fastcc void @vsample_iv(i32, <256 x i32>)

define void @caller_vret() {
; CHECK-LABEL: caller_vret:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB5_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB5_2:
; CHECK-NEXT:    lea %s0, get_v256i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, get_v256i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %r = tail call fastcc <256 x i32> @get_v256i32()
  ret void
}

define void @caller_vret_pass_p0() {
; CHECK-LABEL: caller_vret_pass_p0:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB6_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB6_2:
; CHECK-NEXT:    lea %s0, get_v256i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, get_v256i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    lea %s0, vsample_v@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %p = tail call fastcc <256 x i32> @get_v256i32()
  call fastcc void @vsample_v(<256 x i32> %p)
  ret void
}

define void @caller_vret_pass_p1(i32 %s) {
; CHECK-LABEL: caller_vret_pass_p1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB7_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB7_2:
; CHECK-NEXT:    st %s18, 48(, %s9) # 8-byte Folded Spill
; CHECK-NEXT:    or %s18, 0, %s0
; CHECK-NEXT:    lea %s0, get_v256i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, get_v256i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    lea %s0, vsample_iv@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_iv@hi(, %s0)
; CHECK-NEXT:    or %s0, 0, %s18
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    ld %s18, 48(, %s9) # 8-byte Folded Reload
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %p = tail call fastcc <256 x i32> @get_v256i32()
  call fastcc void @vsample_iv(i32 %s, <256 x i32> %p)
  ret void
}

declare fastcc void @vsample_vv(<256 x i32>, <256 x i32>)
declare fastcc void @vsample_vvv(<256 x i32>, <256 x i32>, <256 x i32>)

define void @caller_vret_pass_p01() {
; CHECK-LABEL: caller_vret_pass_p01:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB8_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB8_2:
; CHECK-NEXT:    lea %s0, get_v256i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, get_v256i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    lea %s0, vsample_vv@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_vv@hi(, %s0)
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v1, (0)1, %v0
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %p = tail call fastcc <256 x i32> @get_v256i32()
  call fastcc void @vsample_vv(<256 x i32> %p, <256 x i32> %p)
  ret void
}

define void @caller_vret_pass_p012() {
; CHECK-LABEL: caller_vret_pass_p012:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB9_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB9_2:
; CHECK-NEXT:    lea %s0, get_v256i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, get_v256i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    lea %s0, vsample_vvv@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_vvv@hi(, %s0)
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v1, (0)1, %v0
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v2, (0)1, %v0
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  %p = tail call fastcc <256 x i32> @get_v256i32()
  call fastcc void @vsample_vvv(<256 x i32> %p, <256 x i32> %p, <256 x i32> %p)
  ret void
}

; Expose register parameter mapping by forcing an explicit vreg move for all parameter positions
declare fastcc void @vsample_vvvvvvv(<256 x i32>, <256 x i32>, <256 x i32>, <256 x i32>, <256 x i32>, <256 x i32>, <256 x i32>)

; TODO improve vreg copy (redundant lea+lvl emitted)
define fastcc void @roundtrip_caller_callee(<256 x i32> %p0, <256 x i32> %p1, <256 x i32> %p2, <256 x i32> %p3, <256 x i32> %p4, <256 x i32> %p5, <256 x i32> %p6) {
; CHECK-LABEL: roundtrip_caller_callee:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB10_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB10_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v7, (0)1, %v0
; CHECK-NEXT:    lea %s0, vsample_vvvvvvv@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_vvvvvvv@hi(, %s0)
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v1, (0)1, %v2
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v2, (0)1, %v3
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v3, (0)1, %v4
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v4, (0)1, %v5
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v5, (0)1, %v6
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v6, (0)1, %v7
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_vvvvvvv(<256 x i32> %p1, <256 x i32> %p2, <256 x i32> %p3, <256 x i32> %p4, <256 x i32> %p5, <256 x i32> %p6, <256 x i32> %p0)
  ret void
}


;;; Non-simple vector types.

declare fastcc void @vsample_v17i64(<17 x i64>)

;; Expect non-power-of-two vector that fit inside one vector register to be widened.
define fastcc void @vreg_arg_v17i64_r1(<256 x i64> %p0, <17 x i64> %p1) {
; CHECK-LABEL: vreg_arg_v17i64_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB11_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB11_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    lea %s0, vsample_v17i64@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i64@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i64(<17 x i64> %p1)
  ret void
}

declare fastcc void @vsample_v17i32(<17 x i32>)

;; Expect non-power-of-two vector that fit inside one vector register to be widened.
define fastcc void @vreg_arg_v17i32_r1(<256 x i32> %p0, <17 x i32> %p1) {
; CHECK-LABEL: vreg_arg_v17i32_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB12_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB12_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    lea %s0, vsample_v17i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i32(<17 x i32> %p1)
  ret void
}

declare fastcc void @vsample_v17i1(<17 x i1>)

;; Expect non-power-of-two vector that fit inside one vector register to be widened.
define fastcc void @vreg_arg_v17i1_r1(<256 x i1> %p0, <17 x i1> %p1) {
; CHECK-LABEL: vreg_arg_v17i1_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB13_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB13_2:
; CHECK-NEXT:    andm %vm1, %vm0, %vm2
; CHECK-NEXT:    lea %s0, vsample_v17i1@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i1@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i1(<17 x i1> %p1)
  ret void
}

;; Expect over-sized non-power-of-two vectors to be split(64bit elements) and widened.
declare fastcc void @vsample_v334i64(<334 x i64>)

define fastcc void @vreg_arg_v334i64_r1(<256 x i64> %p0, <334 x i64> %p1) {
; CHECK-LABEL: vreg_arg_v334i64_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB14_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB14_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v2
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v1, (0)1, %v3
; CHECK-NEXT:    lea %s0, vsample_v334i64@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v334i64@hi(, %s0)
; CHECK-NEXT:    # kill: def $v0 killed $v0 def $vp0 killed $v1
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v334i64(<334 x i64> %p1)
  ret void
}

declare fastcc void @vsample_v334i32(<334 x i32>)

define fastcc void @vreg_arg_v334i32_r1(<256 x i32> %p0, <334 x i32> %p1) {
; CHECK-LABEL: vreg_arg_v334i32_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB15_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB15_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    lea %s0, vsample_v334i32@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v334i32@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v334i32(<334 x i32> %p1)
  ret void
}

declare fastcc void @vsample_v334i1(<334 x i1>)

; FIXME: This test documents a bug in cc lowering:
;        %p1 should live in 'VMP3' and there should be a copy from that to 'VMP1' here.
define fastcc void @vreg_arg_v334i1_r1(<256 x i1> %p0, <334 x i1> %p1) {
; CHECK-LABEL: vreg_arg_v334i1_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB16_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB16_2:
; CHECK-NEXT:    # kill: def $vm2 killed $vm2 killed $vmp1 def $vmp1
; CHECK-NEXT:    # kill: def $vm3 killed $vm3 killed $vmp1 def $vmp1
; CHECK-NEXT:    lea %s0, vsample_v334i1@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v334i1@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v334i1(<334 x i1> %p1)
  ret void
}

; TODO: Implement custom element splitting to get this into vregs.
declare fastcc void @vsample_v17i128(<17 x i128>)

define fastcc void @vreg_arg_v17i128_r1(<256 x i64> %p0, <17 x i128> %p1) {
; CHECK-LABEL: vreg_arg_v17i128_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -448(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB17_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB17_2:
; CHECK-NEXT:    ld %s34, 240(, %s9)
; CHECK-NEXT:    ld %s35, 248(, %s9)
; CHECK-NEXT:    ld %s36, 256(, %s9)
; CHECK-NEXT:    ld %s37, 264(, %s9)
; CHECK-NEXT:    ld %s38, 272(, %s9)
; CHECK-NEXT:    ld %s39, 280(, %s9)
; CHECK-NEXT:    ld %s40, 288(, %s9)
; CHECK-NEXT:    ld %s41, 296(, %s9)
; CHECK-NEXT:    ld %s42, 304(, %s9)
; CHECK-NEXT:    ld %s43, 312(, %s9)
; CHECK-NEXT:    ld %s44, 320(, %s9)
; CHECK-NEXT:    ld %s45, 328(, %s9)
; CHECK-NEXT:    ld %s46, 336(, %s9)
; CHECK-NEXT:    ld %s47, 344(, %s9)
; CHECK-NEXT:    ld %s48, 352(, %s9)
; CHECK-NEXT:    ld %s49, 360(, %s9)
; CHECK-NEXT:    ld %s50, 368(, %s9)
; CHECK-NEXT:    ld %s51, 376(, %s9)
; CHECK-NEXT:    ld %s52, 384(, %s9)
; CHECK-NEXT:    ld %s53, 392(, %s9)
; CHECK-NEXT:    ld %s54, 400(, %s9)
; CHECK-NEXT:    ld %s55, 408(, %s9)
; CHECK-NEXT:    ld %s56, 416(, %s9)
; CHECK-NEXT:    ld %s57, 424(, %s9)
; CHECK-NEXT:    ld %s58, 432(, %s9)
; CHECK-NEXT:    ld %s59, 440(, %s9)
; CHECK-NEXT:    st %s59, 440(, %s11)
; CHECK-NEXT:    st %s58, 432(, %s11)
; CHECK-NEXT:    st %s57, 424(, %s11)
; CHECK-NEXT:    st %s56, 416(, %s11)
; CHECK-NEXT:    st %s55, 408(, %s11)
; CHECK-NEXT:    st %s54, 400(, %s11)
; CHECK-NEXT:    st %s53, 392(, %s11)
; CHECK-NEXT:    st %s52, 384(, %s11)
; CHECK-NEXT:    st %s51, 376(, %s11)
; CHECK-NEXT:    st %s50, 368(, %s11)
; CHECK-NEXT:    st %s49, 360(, %s11)
; CHECK-NEXT:    st %s48, 352(, %s11)
; CHECK-NEXT:    st %s47, 344(, %s11)
; CHECK-NEXT:    st %s46, 336(, %s11)
; CHECK-NEXT:    st %s45, 328(, %s11)
; CHECK-NEXT:    st %s44, 320(, %s11)
; CHECK-NEXT:    st %s43, 312(, %s11)
; CHECK-NEXT:    st %s42, 304(, %s11)
; CHECK-NEXT:    st %s41, 296(, %s11)
; CHECK-NEXT:    st %s40, 288(, %s11)
; CHECK-NEXT:    st %s39, 280(, %s11)
; CHECK-NEXT:    st %s38, 272(, %s11)
; CHECK-NEXT:    st %s37, 264(, %s11)
; CHECK-NEXT:    st %s36, 256(, %s11)
; CHECK-NEXT:    st %s35, 248(, %s11)
; CHECK-NEXT:    lea %s35, vsample_v17i128@lo
; CHECK-NEXT:    and %s35, %s35, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i128@hi(, %s35)
; CHECK-NEXT:    st %s34, 240(, %s11)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i128(<17 x i128> %p1)
  ret void
}

declare fastcc void @vsample_v17i65(<17 x i65>)

define fastcc void @vreg_arg_v17i65_r1(<256 x i64> %p0, <17 x i65> %p1) {
; CHECK-LABEL: vreg_arg_v17i65_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -448(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB18_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB18_2:
; CHECK-NEXT:    ld %s34, 240(, %s9)
; CHECK-NEXT:    ld %s35, 248(, %s9)
; CHECK-NEXT:    ld %s36, 256(, %s9)
; CHECK-NEXT:    ld %s37, 264(, %s9)
; CHECK-NEXT:    ld %s38, 272(, %s9)
; CHECK-NEXT:    ld %s39, 280(, %s9)
; CHECK-NEXT:    ld %s40, 288(, %s9)
; CHECK-NEXT:    ld %s41, 296(, %s9)
; CHECK-NEXT:    ld %s42, 304(, %s9)
; CHECK-NEXT:    ld %s43, 312(, %s9)
; CHECK-NEXT:    ld %s44, 320(, %s9)
; CHECK-NEXT:    ld %s45, 328(, %s9)
; CHECK-NEXT:    ld %s46, 336(, %s9)
; CHECK-NEXT:    ld %s47, 344(, %s9)
; CHECK-NEXT:    ld %s48, 352(, %s9)
; CHECK-NEXT:    ld %s49, 360(, %s9)
; CHECK-NEXT:    ld %s50, 368(, %s9)
; CHECK-NEXT:    ld %s51, 376(, %s9)
; CHECK-NEXT:    ld %s52, 384(, %s9)
; CHECK-NEXT:    ld %s53, 392(, %s9)
; CHECK-NEXT:    ld %s54, 400(, %s9)
; CHECK-NEXT:    ld %s55, 408(, %s9)
; CHECK-NEXT:    ld %s56, 416(, %s9)
; CHECK-NEXT:    ld %s57, 424(, %s9)
; CHECK-NEXT:    ld %s58, 432(, %s9)
; CHECK-NEXT:    ld %s59, 440(, %s9)
; CHECK-NEXT:    st %s59, 440(, %s11)
; CHECK-NEXT:    st %s58, 432(, %s11)
; CHECK-NEXT:    st %s57, 424(, %s11)
; CHECK-NEXT:    st %s56, 416(, %s11)
; CHECK-NEXT:    st %s55, 408(, %s11)
; CHECK-NEXT:    st %s54, 400(, %s11)
; CHECK-NEXT:    st %s53, 392(, %s11)
; CHECK-NEXT:    st %s52, 384(, %s11)
; CHECK-NEXT:    st %s51, 376(, %s11)
; CHECK-NEXT:    st %s50, 368(, %s11)
; CHECK-NEXT:    st %s49, 360(, %s11)
; CHECK-NEXT:    st %s48, 352(, %s11)
; CHECK-NEXT:    st %s47, 344(, %s11)
; CHECK-NEXT:    st %s46, 336(, %s11)
; CHECK-NEXT:    st %s45, 328(, %s11)
; CHECK-NEXT:    st %s44, 320(, %s11)
; CHECK-NEXT:    st %s43, 312(, %s11)
; CHECK-NEXT:    st %s42, 304(, %s11)
; CHECK-NEXT:    st %s41, 296(, %s11)
; CHECK-NEXT:    st %s40, 288(, %s11)
; CHECK-NEXT:    st %s39, 280(, %s11)
; CHECK-NEXT:    st %s38, 272(, %s11)
; CHECK-NEXT:    st %s37, 264(, %s11)
; CHECK-NEXT:    st %s36, 256(, %s11)
; CHECK-NEXT:    st %s35, 248(, %s11)
; CHECK-NEXT:    lea %s35, vsample_v17i65@lo
; CHECK-NEXT:    and %s35, %s35, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i65@hi(, %s35)
; CHECK-NEXT:    st %s34, 240(, %s11)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i65(<17 x i65> %p1)
  ret void
}

;; Vectors with under-sized elements.
declare fastcc void @vsample_v17i16(<17 x i16>)

define fastcc void @vreg_arg_v17i16_r1(<256 x i16> %p0, <17 x i16> %p1) {
; CHECK-LABEL: vreg_arg_v17i16_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB19_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB19_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    lea %s0, vsample_v17i16@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i16@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i16(<17 x i16> %p1)
  ret void
}

declare fastcc void @vsample_v17i13(<17 x i13>)

define fastcc void @vreg_arg_v17i13_r1(<256 x i13> %p0, <17 x i13> %p1) {
; CHECK-LABEL: vreg_arg_v17i13_r1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -240(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB20_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB20_2:
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    lea %s0, vsample_v17i13@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, vsample_v17i13@hi(, %s0)
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
  call fastcc void @vsample_v17i13(<17 x i13> %p1)
  ret void
}
