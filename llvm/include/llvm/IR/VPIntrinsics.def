//===-- IR/VPIntrinsics.def - Describes llvm.vp.* Intrinsics -*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains descriptions of the various Vector Predication intrinsics.
// This is used as a central place for enumerating the different instructions
// and should eventually be the place to put comments about the instructions.
//
//===----------------------------------------------------------------------===//

// NOTE: NO INCLUDE GUARD DESIRED!

// Provide definitions of macros so that users of this file do not have to
// define everything to use it...
//
// Register a VP intrinsic and begin its property scope.
// All VP intrinsic scopes are top level, ie it is illegal to place a
// BEGIN_REGISTER_VP_INTRINSIC within a VP intrinsic scope.
// \p VPID     The VP intrinsic id.
// \p MASKPOS  The mask operand position.
// \p EVLPOS   The explicit vector length operand position.
#ifndef BEGIN_REGISTER_VP_INTRINSIC
#define BEGIN_REGISTER_VP_INTRINSIC(VPID, MASKPOS, EVLPOS)
#endif

#ifndef END_REGISTER_VP_INTRINSIC
#define END_REGISTER_VP_INTRINSIC(VPID)
#endif

#ifndef END_REGISTER_VP_SDNODE
#define END_REGISTER_VP_SDNODE(VPISD)
#endif

///// REGISTER macros /////
// These always have to come first
// This VP Intrinsic is a memory operation
// The pointer arg is at POINTERPOS and the data arg is at DATAPOS.
#ifndef HANDLE_VP_IS_MEMOP
#define HANDLE_VP_IS_MEMOP(POINTERPOS, DATAPOS)
#endif

/// This VP Intrinsic lowers to this VP SDNode.
#ifndef HANDLE_VP_TO_SDNODE
#define HANDLE_VP_TO_SDNODE(VPISD)
#endif

// helper macro to end VP brackes with a 1:1 ISD<>IntrinsicID mapping
#define END_REGISTER_CASES(VPID, VPISD)                                        \
  HANDLE_VP_TO_SDNODE(VPISD)                                                   \
  END_REGISTER_VP_INTRINSIC(VPID)                                              \
  END_REGISTER_VP_SDNODE(VPISD)

// Register a new VP SDNode and begin its property scope.
// When the SDNode scope is nested within a VP intrinsic scope, it is
// implicitly registered as the canonical SDNode for this VP intrinsic. There
// is one VP intrinsic that maps directly to one SDNode that goes by the
// same name.  Since the operands are also the same, we open the property
// scopes for both the VPIntrinsic and the SDNode at once.
// \p SDOPC     The SelectionDAG Node id (eg VP_ADD).
// \p LEGALPOS The operand position of the SDNode that is used for legalizing
//             this SDNode. This can be `-1`, in which case the return type of
//             the SDNode is used.
// \p TDNAME   The name of the TableGen definition of this SDNode.
// \p MASKPOS  The mask operand position.
// \p EVLPOS   The explicit vector length operand position.
#ifndef BEGIN_REGISTER_VP_SDNODE
#define BEGIN_REGISTER_VP_SDNODE(SDOPC, LEGALPOS, TDNAME, MASKPOS, EVLPOS)
#endif

// End the property scope of a new VP SDNode.
#ifndef END_REGISTER_VP_SDNODE
#define END_REGISTER_VP_SDNODE(SDOPC)
#endif

// Helper macros for the common "1:1 - Intrinsic : SDNode" case.
//
// There is one VP intrinsic that maps directly to one SDNode that goes by the
// same name.  Since the operands are also the same, we open the property
// scopes for both the VPIntrinsic and the SDNode at once.
//
// \p INTRIN   The canonical name (eg `vp_add`, which at the same time is the
//             name of the intrinsic and the TableGen def of the SDNode).
// \p MASKPOS  The mask operand position.
// \p EVLPOS   The explicit vector length operand position.
// \p SDOPC    The SelectionDAG Node id (eg VP_ADD).
// \p LEGALPOS The operand position of the SDNode that is used for legalizing
//             this SDNode. This can be `-1`, in which case the return type of
//             the SDNode is used.
#define BEGIN_REGISTER_VP(INTRIN, MASKPOS, EVLPOS, SDOPC, LEGALPOS) \
BEGIN_REGISTER_VP_INTRINSIC(INTRIN, MASKPOS, EVLPOS) \
BEGIN_REGISTER_VP_SDNODE(SDOPC, LEGALPOS, INTRIN, MASKPOS, EVLPOS)

#define END_REGISTER_VP(INTRIN, SDOPC) \
END_REGISTER_VP_INTRINSIC(INTRIN) \
END_REGISTER_VP_SDNODE(SDOPC)


// The following macros attach properties to the scope they are placed in. This
// assigns the property to the VP Intrinsic and/or SDNode that belongs to the
// scope.
//
// Property Macros {

// The intrinsic and/or SDNode has the same function as this LLVM IR Opcode.
// \p OPC  The standard IR opcode.
#ifndef HANDLE_VP_TO_OPC
#define HANDLE_VP_TO_OPC(OPC)
#endif

// The intrinsic and/or SDNode is the cannonical VP representation for the
// SDNode with Opcode \p SDOPC.
#ifndef HANDLE_VP_TO_SD
#define HANDLE_VP_TO_SD(SDOPC)
#endif

// This is a reduction intrinsic with accumulator arg at ACCUPOS, reduced vector
// arg at VECTORPOS.
#ifndef HANDLE_VP_REDUCTION
#define HANDLE_VP_REDUCTION(ACCUPOS, VECTORPOS, SCALAROC, SCALARINTRIN, SCALARISD)
#endif

// End the property scope of a VP intrinsic.
#ifndef END_REGISTER_VP_INTRINSIC
#define END_REGISTER_VP_INTRINSIC(VPID)
#endif

// Map this VP intrinsic to its cannonical functional intrinsic.
#ifndef HANDLE_VP_TO_INTRIN
#define HANDLE_VP_TO_INTRIN(ID)
#endif

#ifndef HANDLE_VP_IS_UNARY
#define HANDLE_VP_IS_UNARY
#endif

#ifndef HANDLE_VP_IS_BINARY
#define HANDLE_VP_IS_BINARY
#endif

#ifndef HANDLE_VP_IS_TERNARY
#define HANDLE_VP_IS_TERNARY
#endif

// This VP Intrinsic is a comparison
// (only count data params)
#ifndef HANDLE_VP_IS_XCMP
#define HANDLE_VP_IS_XCMP
#endif

// link this VP ID to a relaxed (fp semantics) VP OC
#ifndef HANDLE_VP_TO_RELAXEDSD
#define HANDLE_VP_TO_RELAXEDSD(RELAXEDSD)
#endif

// Whether the intrinsic may have a rounding mode or exception behavior operand
// bundle.
// \p HASROUND   '1' if the intrinsic can have a rounding mode operand bundle,
//               '0' otherwise.
// \p HASEXCEPT  '1' if the intrinsic can have an exception behavior operand
//               bundle, '0' otherwise.
// \p INTRINID  The constrained fp intrinsic this VP intrinsic corresponds to.
#ifndef HANDLE_VP_TO_CONSTRAINEDFP
#define HANDLE_VP_TO_CONSTRAINEDFP(HASROUND, HASEXCEPT, INTRINID)
#endif

// Map this VP intrinsic to its canonical functional intrinsic.
#ifndef HANDLE_VP_TO_INTRIN
#define HANDLE_VP_TO_INTRIN(ID)
#endif

// This VP Intrinsic is a memory operation
// The pointer arg is at POINTERPOS and the data arg is at DATAPOS.
#ifndef HANDLE_VP_IS_MEMOP
#define HANDLE_VP_IS_MEMOP(VPID, POINTERPOS, DATAPOS)
#endif

// Map this VP reduction intrinsic to its reduction operand positions.
#ifndef HANDLE_VP_REDUCTION
#define HANDLE_VP_REDUCTION(ACCUPOS, VECTORPOS, SCALAROC, SCALARINTRIN, SCALARISD)
#endif

/// } Property Macros

///// Integer Arithmetic {

// Specialized helper macro for integer binary operators (%x, %y, %mask, %evl).
#ifdef HELPER_REGISTER_BINARY_INT_VP
#error "The internal helper macro HELPER_REGISTER_BINARY_INT_VP is already defined!"
#endif

#define HELPER_REGISTER_BINARY_INT_VP(INTRIN, SDOPC, IROPC) \
BEGIN_REGISTER_VP(INTRIN, 2, 3, VP_##SDOPC, -1) \
HANDLE_VP_TO_OPC(IROPC) \
HANDLE_VP_IS_BINARY \
HANDLE_VP_TO_SD(SDOPC) \
END_REGISTER_VP(INTRIN, VP_##SDOPC)

#define HELPER_REGISTER_BINARY_INT_VP_EXT(INTRIN, SDOPC, VPOPC, IROPC) \
BEGIN_REGISTER_VP(INTRIN, 2, 3, VPOPC, -1) \
HANDLE_VP_TO_OPC(IROPC) \
HANDLE_VP_IS_BINARY \
HANDLE_VP_TO_SD(SDOPC) \
END_REGISTER_VP(INTRIN, VPOPC)

HELPER_REGISTER_BINARY_INT_VP(vp_add, ADD, Add)

// llvm.vp.and(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_and, AND, And)

// llvm.vp.ashr(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP_EXT(vp_ashr, SRA, VP_ASHR, AShr)

// llvm.vp.lshr(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP_EXT(vp_lshr, SRL, VP_LSHR, LShr)

// llvm.vp.mul(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_mul, MUL, Mul)

// llvm.vp.or(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_or, OR, Or)

// llvm.vp.sdiv(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_sdiv, SDIV, SDiv)

// llvm.vp.shl(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_shl, SHL, Shl)

// llvm.vp.srem(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_srem, SREM, SRem)

// llvm.vp.sub(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_sub, SUB, Sub)

// llvm.vp.udiv(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_udiv, UDIV, UDiv)

// llvm.vp.urem(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_urem, UREM, URem)

// llvm.vp.xor(x,y,mask,vlen)
HELPER_REGISTER_BINARY_INT_VP(vp_xor, XOR, Xor)

#undef HELPER_REGISTER_BINARY_INT_VP
#undef HELPER_REGISTER_BINARY_INT_VP_EXT

// llvm.vp.ctpop(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_ctpop, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_CTPOP, -1, vp_ctpop, 1, 2)
HANDLE_VP_TO_INTRIN(ctpop)
HANDLE_VP_IS_UNARY
END_REGISTER_CASES(vp_ctpop, VP_CTPOP)

///// } Integer Arithmetic

///// Floating-Point Arithmetic {

// Specialized helper macro for floating-point binary operators
// <operation>(%x, %y, %mask, %evl).
#ifdef HELPER_REGISTER_BINARY_FP_VP
#error                                                                         \
    "The internal helper macro HELPER_REGISTER_BINARY_FP_VP is already defined!"
#endif
#define HELPER_REGISTER_BINARY_FP_VP(OPSUFFIX, SDOPC, OPC)                     \
  BEGIN_REGISTER_VP(vp_##OPSUFFIX, 2, 3, SDOPC, -1)                            \
  HANDLE_VP_IS_BINARY                                                          \
  HANDLE_VP_TO_OPC(OPC)                                                        \
  HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_##OPSUFFIX)        \
  END_REGISTER_VP(vp_##OPSUFFIX, SDOPC)

// llvm.vp.fadd(x,y,mask,vlen)
HELPER_REGISTER_BINARY_FP_VP(fadd, VP_FADD, FAdd)

// llvm.vp.fsub(x,y,mask,vlen)
HELPER_REGISTER_BINARY_FP_VP(fsub, VP_FSUB, FSub)

// llvm.vp.fmul(x,y,mask,vlen)
HELPER_REGISTER_BINARY_FP_VP(fmul, VP_FMUL, FMul)

// llvm.vp.fdiv(x,y,mask,vlen)
HELPER_REGISTER_BINARY_FP_VP(fdiv, VP_FDIV, FDiv)

// llvm.vp.frem(x,y,mask,vlen)
HELPER_REGISTER_BINARY_FP_VP(frem, VP_FREM, FRem)

#undef HELPER_REGISTER_BINARY_FP_VP

// llvm.vp.fneg(x,mask,vlen)
BEGIN_REGISTER_VP(vp_fneg, 1, 2, VP_FNEG, -1)
HANDLE_VP_TO_OPC(FNeg)
HANDLE_VP_TO_SD(FNEG)
HANDLE_VP_TO_CONSTRAINEDFP(1, 0, not_intrinsic) // experimental_constrained_fneg
HANDLE_VP_IS_UNARY
END_REGISTER_VP(vp_fneg, VP_FNEG)



// llvm.vp.fma(x,y,z,mask,vlen)
BEGIN_REGISTER_VP(vp_fma, 3, 4, VP_FMA, -1)
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_fma)
HANDLE_VP_TO_INTRIN(fma)
HANDLE_VP_TO_SD(FMA)
HANDLE_VP_IS_TERNARY
END_REGISTER_CASES(vp_fma, VP_FMA)

///// } Floating-Point Arithmetic

///// Cast, Extend & Round /////

// llvm.vp.ceil(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_ceil, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FCEIL, -1, vp_fceil, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_ceil)
HANDLE_VP_TO_INTRIN(ceil)
END_REGISTER_CASES(vp_ceil, VP_FCEIL)

// Truncate fp to nearest integer.
// llvm.vp.trunc(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_trunc, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_TRUNC, -1, vp_trunc, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_trunc)
HANDLE_VP_TO_INTRIN(trunc)
END_REGISTER_CASES(vp_trunc, VP_TRUNC)

// Truncate high bits in an integer (isel only)
// BEGIN_REGISTER_VP_SDNODE(VP_ITRUNC, -1, vp_itrunc, 1, 2)
// HANDLE_VP_TO_OPC(Trunc)
// END_REGISTER_VP_SDNODE(VP_ITRUNC)

// llvm.vp.floor(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_floor, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FFLOOR, -1, vp_ffloor, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_floor)
HANDLE_VP_TO_INTRIN(floor)
END_REGISTER_CASES(vp_floor, VP_FFLOOR)

// llvm.vp.fpext(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_fpext, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FP_EXTEND, -1, vp_fpext, 1, 2)
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_fpext)
HANDLE_VP_TO_OPC(FPExt)
END_REGISTER_CASES(vp_fpext, VP_FP_EXTEND)

// Truncate double-to-float
// llvm.vp.fptrunc(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_fptrunc, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FP_TRUNC, -1, vp_fptrunc, 1, 2)
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_fptrunc)
HANDLE_VP_TO_OPC(FPTrunc)
END_REGISTER_CASES(vp_fptrunc, VP_FP_TRUNC)

// llvm.vp.fptoui(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_fptoui, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FP_TO_UINT, -1, vp_fp_to_uint, 1, 2)
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_fptoui)
HANDLE_VP_TO_OPC(FPToUI)
END_REGISTER_CASES(vp_fptoui, VP_FP_TO_UINT)

// llvm.vp.fptosi(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_fptosi, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FP_TO_SINT, -1, vp_fp_to_sint, 1, 2)
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_fptosi)
HANDLE_VP_TO_OPC(FPToSI)
END_REGISTER_CASES(vp_fptosi, VP_FP_TO_SINT)

// llvm.vp.uitofp(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_uitofp, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_UINT_TO_FP, -1, vp_uint_to_fp, 1, 2)
HANDLE_VP_TO_OPC(UIToFP)
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_uitofp)
END_REGISTER_CASES(vp_uitofp, VP_UINT_TO_FP)

// llvm.vp.sitofp(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_sitofp, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_SINT_TO_FP, -1, vp_sint_to_fp, 1, 2)
HANDLE_VP_TO_OPC(SIToFP)
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_sitofp)
END_REGISTER_CASES(vp_sitofp, VP_SINT_TO_FP)

// llvm.vp.round(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_round, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FROUND, -1, vp_fround, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_round)
HANDLE_VP_TO_INTRIN(round)
END_REGISTER_CASES(vp_round, VP_FROUND)

// llvm.vp.rint(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_rint, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FRINT, -1, vp_frint, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_rint)
HANDLE_VP_TO_INTRIN(rint)
END_REGISTER_CASES(vp_rint, VP_FRINT)

// llvm.vp.nearbyint(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_nearbyint, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FNEARBYINT, -1, vp_fnearbyint, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_nearbyint)
HANDLE_VP_TO_INTRIN(nearbyint)
END_REGISTER_CASES(vp_nearbyint, VP_FNEARBYINT)

///// Math Funcs /////

// llvm.vp.sqrt(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_sqrt, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FSQRT, -1, vp_fsqrt, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_sqrt)
HANDLE_VP_TO_INTRIN(sqrt)
END_REGISTER_CASES(vp_sqrt, VP_FSQRT)

// llvm.vp.pow(x,y,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_pow, 2, 3)
BEGIN_REGISTER_VP_SDNODE(VP_FPOW, -1, vp_fpow, 2, 3)
HANDLE_VP_IS_BINARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_pow)
HANDLE_VP_TO_INTRIN(pow)
END_REGISTER_CASES(vp_pow, VP_FPOW)

// llvm.vp.powi(x,y,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_powi, 2, 3)
BEGIN_REGISTER_VP_SDNODE(VP_FPOWI, -1, vp_fpowi, 2, 3)
HANDLE_VP_IS_BINARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_powi)
HANDLE_VP_TO_INTRIN(powi)
END_REGISTER_CASES(vp_powi, VP_FPOWI)

// llvm.vp.maxnum(x,y,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_maxnum, 2, 3)
BEGIN_REGISTER_VP_SDNODE(VP_FMAXNUM, -1, vp_fmaxnum, 2, 3)
HANDLE_VP_IS_BINARY
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_maxnum)
HANDLE_VP_TO_INTRIN(maxnum)
END_REGISTER_CASES(vp_maxnum, VP_FMAXNUM)

// llvm.vp.minnum(x,y,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_minnum, 2, 3)
BEGIN_REGISTER_VP_SDNODE(VP_FMINNUM, -1, vp_fminnum, 2, 3)
HANDLE_VP_IS_BINARY
HANDLE_VP_TO_CONSTRAINEDFP(0, 1, experimental_constrained_minnum)
HANDLE_VP_TO_INTRIN(minnum)
END_REGISTER_CASES(vp_minnum, VP_FMINNUM)

// llvm.vp.sin(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_sin, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FSIN, -1, vp_fsin, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_sin)
HANDLE_VP_TO_INTRIN(sin)
END_REGISTER_CASES(vp_sin, VP_FSIN)

// llvm.vp.cos(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_cos, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FCOS, -1, vp_fcos, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_cos)
HANDLE_VP_TO_INTRIN(cos)
END_REGISTER_CASES(vp_cos, VP_FCOS)

// llvm.vp.log(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_log, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FLOG, -1, vp_flog, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_log)
HANDLE_VP_TO_INTRIN(log)
END_REGISTER_CASES(vp_log, VP_FLOG)

// llvm.vp.log10(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_log10, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FLOG10, -1, vp_flog10, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_log10)
HANDLE_VP_TO_INTRIN(log10)
END_REGISTER_CASES(vp_log10, VP_FLOG10)

// llvm.vp.log2(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_log2, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FLOG2, -1, vp_flog2, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_log2)
HANDLE_VP_TO_INTRIN(log2)
END_REGISTER_CASES(vp_log2, VP_FLOG2)

// llvm.vp.exp(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_exp, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FEXP, -1, vp_fexp, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_exp)
HANDLE_VP_TO_INTRIN(exp)
END_REGISTER_CASES(vp_exp, VP_FEXP)

// llvm.vp.exp2(x,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_exp2, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_FEXP2, -1, vp_fexp2, 1, 2)
HANDLE_VP_IS_UNARY
HANDLE_VP_TO_CONSTRAINEDFP(1, 1, experimental_constrained_exp2)
HANDLE_VP_TO_INTRIN(exp2)
END_REGISTER_CASES(vp_exp2, VP_FEXP2)

///// Comparison /////

// llvm.vp.fcmp(x,y,pred,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_fcmp, 3, 4)
HANDLE_VP_TO_OPC(FCmp)
HANDLE_VP_IS_XCMP
END_REGISTER_VP_INTRINSIC(vp_fcmp)

// llvm.vp.icmp(x,y,cmp_pred,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_icmp, 3, 4)
HANDLE_VP_TO_OPC(ICmp)
HANDLE_VP_IS_XCMP
END_REGISTER_VP_INTRINSIC(vp_icmp)

// VP_SETCC (ISel only)
BEGIN_REGISTER_VP_SDNODE(VP_SETCC, -1, vp_setcc, 3, 4)
END_REGISTER_VP_SDNODE(VP_SETCC)

///// Memory Operations /////

// llvm.vp.scatter(ptr,val,mask,vlen)
// VP gather and scatter - load and store operations for a vector of
// random addresses with additional mask and vector length operand that
// prevents memory accesses to the masked-off lanes.
//
// Val, OutChain = VP_GATHER(InChain, BasePtr, Index, Scale, Mask, EVL)
// OutChain = VP_SCATTER(InChain, Value, BasePtr, Index, Scale, Mask, EVL)
//
// The Index operand can have more vector elements than the other operands
// due to type legalization. The extra elements are ignored.

///// Memory Operations {

// llvm.vp.store(ptr,val,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_store, 2, 3)
// chain = VP_STORE chain,val,base,offset,mask,evl
BEGIN_REGISTER_VP_SDNODE(VP_STORE, 0, vp_store, 4, 5)
HANDLE_VP_TO_OPC(Store)
HANDLE_VP_TO_INTRIN(masked_store)
HANDLE_VP_IS_MEMOP(1, 0)
END_REGISTER_VP(vp_store, VP_STORE)

// llvm.vp.scatter(ptr,val,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_scatter, 2, 3)
// chain = VP_SCATTER chain,val,base,indices,scale,mask,evl
BEGIN_REGISTER_VP_SDNODE(VP_SCATTER, -1, vp_scatter, 5, 6)
HANDLE_VP_TO_INTRIN(masked_scatter)
HANDLE_VP_IS_MEMOP(1, 0)
END_REGISTER_VP(vp_scatter, VP_SCATTER)

// llvm.vp.load(ptr,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_load, 1, 2)
// val,chain = VP_LOAD chain,base,offset,mask,evl
BEGIN_REGISTER_VP_SDNODE(VP_LOAD, -1, vp_load, 3, 4)
HANDLE_VP_TO_OPC(Load)
HANDLE_VP_TO_INTRIN(masked_load)
HANDLE_VP_IS_MEMOP(0, None)
END_REGISTER_VP(vp_load, VP_LOAD)

// llvm.vp.gather(ptr,mask,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_gather, 1, 2)
// val,chain = VP_GATHER chain,base,indices,scale,mask,evl
BEGIN_REGISTER_VP_SDNODE(VP_GATHER, -1, vp_gather, 4, 5)
HANDLE_VP_TO_INTRIN(masked_gather)
HANDLE_VP_IS_MEMOP(0, None)
END_REGISTER_VP(vp_gather, VP_GATHER)

///// } Memory Operations

///// Reductions {

// Specialized helper macro for VP reductions (%start, %x, %mask, %evl).
#ifdef HELPER_REGISTER_REDUCTION_VP
#error "The internal helper macro HELPER_REGISTER_REDUCTION_VP is already defined!"
#endif
#define HELPER_REGISTER_REDUCTION_VP(VPINTRIN, SDOPC, INTRIN, SCALAROPC, SCALARINTRIN, SCALARISD) \
BEGIN_REGISTER_VP(VPINTRIN, 2, 3, SDOPC, 1) \
HANDLE_VP_TO_INTRIN(INTRIN) \
HANDLE_VP_REDUCTION(0, 1, SCALAROPC, SCALARINTRIN, SCALARISD) \
END_REGISTER_VP(VPINTRIN, SDOPC)

// #define HANDLE_VP_REDUCTION(ID, STARTPOS, VECTORPOS)

// llvm.vp.reduce.add(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_add, VP_REDUCE_ADD,
                             vector_reduce_add, Add, None, ADD)

// llvm.vp.reduce.mul(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_mul, VP_REDUCE_MUL,
                             vector_reduce_mul, Mul, None, MUL)

// llvm.vp.reduce.and(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_and, VP_REDUCE_AND,
                             vector_reduce_and, And, None, AND)

// llvm.vp.reduce.or(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_or, VP_REDUCE_OR,
                             vector_reduce_or, Or, None, OR)

// llvm.vp.reduce.xor(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_xor, VP_REDUCE_XOR,
                             vector_reduce_xor, Xor, None, XOR)

// llvm.vp.reduce.smax(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_smax, VP_REDUCE_SMAX,
                             vector_reduce_smax, None, int_smax, SMAX)

// llvm.vp.reduce.smin(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_smin, VP_REDUCE_SMIN,
                             vector_reduce_smin, None, int_smin, SMIN)

// llvm.vp.reduce.umax(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_umax, VP_REDUCE_UMAX,
                             vector_reduce_umax, None, int_umax, UMAX)

// llvm.vp.reduce.umin(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_umin, VP_REDUCE_UMIN,
                             vector_reduce_umin, None, int_umin, UMIN)

// llvm.vp.reduce.fmax(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_fmax, VP_REDUCE_FMAX,
                             vector_reduce_fmax, None, int_maxnum, FMAXNUM)

// llvm.vp.reduce.fmin(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_VP(vp_reduce_fmin, VP_REDUCE_FMIN,
                             vector_reduce_fmin, None, int_minnum, FMINNUM)

#undef HELPER_REGISTER_REDUCTION_VP

// Specialized helper macro for VP reductions as above but with two forms:
// sequential and reassociative. These manifest as the presence of 'reassoc'
// fast-math flags in the IR and as two distinct ISD opcodes in the
// SelectionDAG.
#ifdef HELPER_REGISTER_REDUCTION_SEQ_VP
#error "The internal helper macro HELPER_REGISTER_REDUCTION_SEQ_VP is already defined!"
#endif
#define HELPER_REGISTER_REDUCTION_SEQ_VP(VPINTRIN, SDOPC, SEQ_SDOPC, INTRIN, SCALAROPC, SCALARISD) \
BEGIN_REGISTER_VP_INTRINSIC(VPINTRIN, 2, 3) \
BEGIN_REGISTER_VP_SDNODE(SDOPC, 1, VPINTRIN, 2, 3) \
HANDLE_VP_REDUCTION(0, 1, SCALAROPC, None, SCALARISD) \
END_REGISTER_VP_SDNODE(SDOPC) \
BEGIN_REGISTER_VP_SDNODE(SEQ_SDOPC, 1, VPINTRIN, 2, 3) \
HANDLE_VP_REDUCTION(0, 1, SCALAROPC, None, SCALARISD) \
END_REGISTER_VP_SDNODE(SEQ_SDOPC) \
HANDLE_VP_TO_INTRIN(INTRIN) \
END_REGISTER_VP_INTRINSIC(VPINTRIN)

// llvm.vp.reduce.fadd(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_SEQ_VP(vp_reduce_fadd, VP_REDUCE_FADD,
                                 VP_REDUCE_SEQ_FADD,
                                 vector_reduce_fadd, FAdd, FADD)

// llvm.vp.reduce.fmul(start,x,mask,vlen)
HELPER_REGISTER_REDUCTION_SEQ_VP(vp_reduce_fmul, VP_REDUCE_FMUL,
                                 VP_REDUCE_SEQ_FMUL,
                                 vector_reduce_fmul, FMul, FMUL)

#undef HELPER_REGISTER_REDUCTION_SEQ_VP

///// } Reductions

///// Shuffles {

// llvm.vp.select(mask,on_true,on_false,vlen)
BEGIN_REGISTER_VP_INTRINSIC(vp_select, 0, 3)
BEGIN_REGISTER_VP_SDNODE(VP_SELECT, -1, vp_select, 0, 3)
END_REGISTER_CASES(vp_select, VP_SELECT)

// llvm.vp.compress(x,mask,vlen)
/// VP_COMPRESS(VEC1, MASK, VLEN) - Returns a vector, of the same type as
/// VEC1.
BEGIN_REGISTER_VP_INTRINSIC(vp_compress, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_COMPRESS, -1, vp_compress, 1, 2)
END_REGISTER_CASES(vp_compress, VP_COMPRESS)

// llvm.vp.expand(x,mask,vlen)
/// VP_EXPAND(VEC1, MASK, VLEN) - Returns a vector, of the same type as
/// VEC1.
BEGIN_REGISTER_VP_INTRINSIC(vp_expand, 1, 2)
BEGIN_REGISTER_VP_SDNODE(VP_EXPAND, -1, vp_expand, 1, 2)
END_REGISTER_CASES(vp_expand, VP_EXPAND)

// llvm.vp.vshift(x,amount,mask,vlen)
/// VP_VSHIFT(VEC1, AMOUNT, MASK, VLEN) - Returns a vector, of the same type as
/// VEC1. AMOUNT is an integer value. The returned vector is equivalent
/// to VEC1 shifted by AMOUNT (RETURNED_VEC[idx] = VEC1[idx + AMOUNT]).
BEGIN_REGISTER_VP_INTRINSIC(vp_vshift, 2, 3)
BEGIN_REGISTER_VP_SDNODE(VP_VSHIFT, -1, vp_vshift, 2, 3)
END_REGISTER_CASES(vp_vshift, VP_VSHIFT)

///// } Shuffles

#undef BEGIN_REGISTER_VP
#undef BEGIN_REGISTER_VP_INTRINSIC
#undef BEGIN_REGISTER_VP_SDNODE
#undef END_REGISTER_CASES
#undef END_REGISTER_VP
#undef END_REGISTER_VP_INTRINSIC
#undef END_REGISTER_VP_SDNODE
#undef HANDLE_VP_IS_BINARY
#undef HANDLE_VP_IS_MEMOP
#undef HANDLE_VP_IS_TERNARY
#undef HANDLE_VP_IS_UNARY
#undef HANDLE_VP_IS_XCMP
#undef HANDLE_VP_REDUCTION
#undef HANDLE_VP_TO_CONSTRAINEDFP
#undef HANDLE_VP_TO_INTRIN
#undef HANDLE_VP_TO_OPC
#undef HANDLE_VP_TO_RELAXEDSD
#undef HANDLE_VP_TO_SD
#undef HANDLE_VP_TO_SDNODE
